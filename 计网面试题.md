\1. 基础2. 应用层2.1 HTTP	2.2 HTTPS2.3 DNS3. TCP 4. IP5. 场景题

#### 1. 基础

1. 为什么要有TCP/IP：同一台设备上进程间的通信有管道、消息队列、共享内存、信号等方式，**而** 。而这个TCP/IP协议是分层的，每层有各自的职责并与其上下层进行通信
2. OSI七层协议：（应表会传网数物）

- - **应用层功能包括验证资源可用性和支持传输任何数据格式** ，
  - 表示层将数据编码和解码与压缩与加密解密 ，
  - 会话层控制设备的连接与断点续传，
  - **传输层将数据分解为多个****数据段****与加上TCP头和重组数据并进行流量控制与传输的完整性** ，
  - **网络层进行两个不同网络之间的寻址与数据路由**并且将传输层的数据段进一步分解为**数据包**，
  - 数据链路层提供同一网络上两台设备之间的数据传输，将网络层的数据包分解为更小的**数据帧**
  - 物理层定义物理设备的规格如电缆工作电压、无线设备的频率，将数据转换为位流。

- 应用层协议有（HTTP、HTTPS、DNS），传输层协议有（TCP、UDP），网络层协议有（IP、ARP、ICMP）。OSI只是理论模型，实际上因特网的网络模型使用了TCP/IP网络，对OSI进行了简化，把应用层、表示层、会话层统一为了应用层，数据链路层和物理层统一为了网络接口层。

1. TCP/IP有哪几层：应用层、传输层、网络层、网络接口层。

- - 应用层：（**HTTP报文**）**为应用程序提供了访问其他层的能力和支持传输任何数据格式** ，定义**了应用程序交换数据的协议**（HTTP、HTTPS、DNS）

- - - **即忽略如何传输给对方，只关心客户端和服务端如何处理通信资源****（如http请求/响应报文）**

- - 传输层：（**添加TCP头**）为应用程序提供数据传输服务，**为了方便传输将数据分为多个不超过****MSS****（TCP最大报文段长度不包括TCP首部）的小数据控制并添加TCP头部**，进行流量控制，保证数据传输的完整性。（TCP提供一对一的可靠传输，UDP提供一对一或一对多的不可靠的传输，TCP比UDP多了流量控制、超时重传、拥塞控制等），

- - - **提供处于网络连接中的两个计算机之间的数据传输**

- - 网络层：（**添加IP头**）负责IP寻址和路由功能，（IP协议负责寻址和路由，ARP协议地址解析只工作在局域网中获得目标IP的MAC地址，ICMP提供诊断并报告错误）、分片（**MTU规****定IP包的大最大为1500字节，包括了TCP首部与IP首部**），

- - - **处理在网络中流动的数据包如何找到对方计算机的路径**

- - 网络接口层：（**添加MAC头，将TCP/IP包封装成帧**）将TCP/IP数据包放到网络介质上并从网络介质上接受TCP/IP数据包，，如以太网、WIFI等。使用MAC地址在同一网络中不同设备间传输数据（在以太网中用MAC地址，使用ARP获取对方地址）

- - - **处理连接网络的硬件部分（包括网卡、操作系统、路由器等）**，**使得TCP/IP包可以连接不同的网络类型
      **![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724238628042-e0692e44-c5ea-4ba5-a91c-6ec26592776b.png)

1. 为什么要分层？ 
   首先可以进行解耦，每层不用关心上下层的实现，只使用提供的接口服务，将大问题转化为若干小问题，同时若发生网络问题可以快速定位到在哪一层，而且分层后若某层发生改动，其他层不受到影响。如ipv4升级到ipv6，http1.0升级到http2.0
2. 键入网址后，期间发生了什么？

1. 1. 解析URL，确定服务器名（域名），资源路径，端口信息，进而生成http请求报文（包括请求头（方法、版本、URL），消息行，消息体）。
   2. 域名解析，查询服务器对应的IP地址。DNS服务器保存了web域名与IP的对应关系（域名服务器的层级关系类似一个树状结构，根域的DNS服务器信息保存在所有DNS服务器中，因此任何一个DNS服务器可以通过根域服务器一路向下找到目标DNS服务器），流程：浏览器先看本地有没有该域名缓存，若有则直接返回，再问操作系统的缓存，再问hosts文件，都没有再去本地DNS服务器，本地DNS服务器若有缓存则直接返回IP地址，本地若没有则去问根域名服务器，找到顶级域名服务器，再到权威域名服务器，找到域名的IP地址再但返回给浏览器
      浏览器调用Socket库来委托操作系统的协议栈工作
   3. HTTP包通过TCP传输，在发送HTTP请求之前要进行TCP三次握手，第一次握手客户端TCP头部状态位SYN，之后处于SYN-SEND状态，服务端收到后返回SYN并且ACK客户端的SYN，客户端收到服务端的SYN+ACK之后，发送对SYN的ACK，之后处于establised状态（因为一发一收成功），服务端收到客户端的ACK之后也处于establed状态，因为也一发一收成功了。
   4. 到网络层，在TCP连接，收发，断开时都要为TCP包加上IP头，封装成网络包发送给对象。
   5. 再由ARP获得路由器的MAC地址，添加MAC头（源MAC地址和目标MAC地址），首次MAC地址的获取需要ARP在以太网中以广播的形式得到ip地址对应的机器的MAC地址
   6. （经过交换机和路由器）找到目标服务器，进行三次握手
   7. 当三次握手完成，将请求发送到服务器，服务器响应请求，浏览器收到响应进行解析渲染，呈现出来

1. Linux如何收发网络包

应用程序通过系统调用，将数据写到socket中，socket层下面就是传输层，网络层，网络接口层，DMA。

- - 发送：应用程序调用socket发送数据包的接口，为系统调用，将数据从用户空间拷贝到socket发送缓冲区，网络协议栈从socket缓冲区取出数据，并按照TCP/IP协议从上到下处理，使用TCP传输协议发送数据，会拷贝一个新的socket缓冲副本，因为TCP是支持丢失重传的，在收到对方的ACK之前，不会删除这个socket数据，收到ACK之后才会删除（副本被送往网络层，发送完被删除，原始的sk_buff还保存在传输层，等收到ACK时，才会释放原始sk_buff）

#### 2. 应用层

##### 2.1 HTTP	

1. http是什么？
   超文本传输协议，定义点到点之间传输数据（文字、图片、音频、视频等超文本）的规范，用于web客户端与web服务器之间通信。
2. 报文格式：

- - 请求报文：报文首部，报文主体。报文首部包含（请求行，首部字段），请求行为包含（方法，URI，HTTP版本）
  - 响应报文：报文首部包含（HTTP版本、状态码、首部字段）
    ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132299406-889665ea-77b4-4b7d-8362-84973c398e54.png)
  - 通用首部：Cache-Control：请求与响应控制缓存的行为。Connection控制不再转发给代理的首部字段（即为逐条首部），管理持久连接（为close时表示想断开连接，为keep-alive时表示维持连接）。Date表示报文的创建时间。Trailer标识报文主体后出现的首部字段。Transfer-Encoding报文主体采用的编码方式。Via用于追踪请求和响应报文的传输路径（类似于traceout，每经过代理时在Via字段中添加该服务器的信息再转发）
  - 请求首部：Accept通知服务端客户端可以处理的数据类型（type/subtype，还可以指定优先级，先返回优先级高的资源）。Accept-Charset通知服务端客户段支持的字符集。Accept-Encoding为客户端支持的编码方式。Authorization告知服务端用户端的证书认证。Host指定虚拟主机（因为在同一个IP中可能有部署多个域名）。If-Match用于让服务端验证Etag。If-modified-since如果在指定时间之后更新过，服务端可以接受该资源。Max-forward指定可以经过服务器跳转的最大个数。Range指定获取资源的字节范围。User-Agent用于传达浏览器的种类。referer可以让服务端知道请求的原始资源的URI。

1. URI和URL：URI（uniform resource identifier）统一资源标识符，用于标识某一互联网中的资源，URL统一资源定位符，标识资源所在的具体网络地址，标识网络资源除了通过地址以外还有其他的方式（如唯一资源名称）因此URL是URI的一个子集
2. URL和HTTP：URL是定位网络上资源的地址，HTTP协议是网络上传输的协议，URL中会指定HTTP协议。
   ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132312859-7b8c21ca-444e-4674-b12b-d4551914b4e3.png)
3. 状态码1xx为提示信息，为处理的中间状态，2xx表示服务器成功处理了请求，3xx表示重定向，4xx表示客户端请求报文有错，5xx表示服务器处理时内部发生错误
4. http header常见字段host表示请求服务器的域名，content length服务器返回数据的长度，connection字段常用于客户端要求服务器进行长连接以进行请求复用，content-type表示服务器返回客户端的数据格式编码方式，accept表示客户端接受什么格式的数据，content-encoding表明响应的数据压缩的方法
5. get与post区别get是指从服务器获取资源，请求参数一般写在url中（只支持ascii码），post是根据请求头对请求负荷body做出指定处理，参数一般写在body中，get因为是请求资源所以是安全且幂等的，post会对服务器资源进行修改，所以是不安全也不幂等的
6. http缓存技术某些具有重复性的http请求，每次请求得到的数据都一样，可以将这个请求与响应的数据都缓存在本地，下次请求就读取本地的响应，不再通过服务器进行响应，分为强制缓存和协商缓存

- - 强制缓存：**即只要浏览器判断缓存没有过期，就直接使用浏览器本地的缓存，即浏览器决定是否使用缓存**，通过http header的字段cache-Control实现相对时间，浏览器第一次发起请求时**服务器会在响应的头部加上cache-control设置过期时间**，浏览器下次请求该资源的时候会先比较cache-control过期时间大小，计算该资源是否过期，没有过期则直接使用缓存，否则请求服务器，服务器会响应资源并且更新cache-control
  - 协商缓存（**协商缓存需要配合强制缓存在使用，强制缓存未命中才发起协商缓存**）：如服务器响应码为304就会使用本地缓存，**即与服务器协商是否使用缓存**，

- - - Last-modified基于修改时间：第一次请求时**服务器会响应Last-modified字段表示这个资源的最后修改时间，浏览器请求时会将本地的last-modified字段一起发给服务器，服务器比较last-modified的大小**，如果服务器比请求的要大，表示资源有修改过，会返回最新的资源，否则说明资源没有修改，返回304表示浏览器访问本地的缓存。
    - Etag基于唯一标识：服务器比较Etag是否变化，若变化则返回新资源，状态码为200。否则没有修改则返回304浏览器访问本地资源。Last-modified与Etag同时出现则Etag优先级高，因为可能文件修改时间没变的情况下文件内容也可以变化，资源可能在秒内发生修改，而Last-modified并没有改变。
      ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132326908-b372313d-1865-4e61-b11a-08902f5cf3f8.png)

1. HTTP/1.1、HTTP/2、HTTP/3

- - HTTP/1.1对HTTP/1.0的提高

- - - 1.1使用长连接改善了短连接的性能开销，长连接不用每次请求都要进行三次握手。（**即1.0中收到一个响应才能发送下一请求**）
    - 支持pipline管道，**第一个请求发完不用等待响应就可以发送第二个请求，但是响应按照请求顺序返回**。
    - 1.1缺点：服务器是按请求的顺序进行响应，如果某个响应阻塞了可能会导致队头阻塞。头部不加压缩就发送，比较浪费。请求没有优先级控制。

- - HTTP/2.0做了什么优化？ （**头部压缩、二进制传输、Stream并发传输、服务器主动推送**）

- - - HTTP/2.0也是基于HTTPS的，会加密传输。
    - 会**对请求头Header压缩**，在客户端与服务端维护一个请求头信息表，保存请求头信息，之后就不用发送相同的字段了，只发索引号，提高速度
    - 1.1中是纯文本的ASSIC码报文，机器还要将二进制转化为明文报文，而2.0中**报文是二进制格式**，对计算机友好，节省空间并且加快传输的效率，将首部和负载分为两类帧HEADERS和DATA帧，
    - 1.1中同一个连接，响应是按照请求顺序返回的，会有队头阻塞的问题，2.0中采用stream流的设计，**多个stream复用一条TCP连接**，stream中可以包含一个或者多个Message，**一个Message可以看做一个请求或者响应**，Message中又包含多个Frame帧，**即一个stream中可以可以有多个请求或响应**（同一个HTTP请求与响应在同一个Stream中）。不同的Stream帧是可以乱序发送的（**即可以并发不同的Stream**），每一个Frame头部带有streamID，接收端收到帧后通过StreamID将帧组装成THHP消息，**而同一Stream中帧是有序的**，即2.0中实现100个请求并发时，只需要在一个TCP连接中并发100个stream就行了（类似于多路复用），而1.1中并发需要建立100个TCP连接（类似于多线程处理IO）
    - 1.1中服务端响应需要客户端请求才行，而2.0中服务端可以主动向客户端推送资源，比如客户端请求了HTML文件，还需要请求HTML所依赖的JS、CSS文件，而2.0中服务端可以主动推送HTML文件所依赖的资源，减少请求次数。（**可以在Nginx中配置推送的资源**），服务端会在响应的时候，通过PUSH-PROMISE帧告知客户端，接下来推送的资源所在的streamID（服务端使用偶数stream，客户端使用奇数stream）

- - HTTP/3的优化

- - - 1.1使用管道技术解决了请求的队头阻塞，但是没有解决响应的队投阻塞。2.0使用多个stream复用一个TCP连接，但是一旦丢包就会阻塞所有的HTTP请求，会发生TCP层的队头阻塞。
    - 2.0中使用TCP协议来传输数据，TCP是字节流协议，**TCP层必须保证接收到的字节数据是完整且连续的，内核才会将缓冲区中的数据拷贝到用户空间中**，当中间某个数据还没有到达时，即使后面的数据到达了也无法返回给用户空间，只能放在内核空间中，只有等到这个数据到达内核才会把数据返回给程序，**即会发生TCP层面的队头阻塞。当发生丢包，在一个TCP连接中的所有HTTP请求都必须等待这个丢了的包重传回来。**
    - 3.0优化：**无队头阻塞、更快的连接建立、连接迁移**  QUIC是基于UDP的伪TCP+TLS+2.0多路复用。

- - - - 无队头阻塞：3.0将TCP协议改成了UDP协议，UDP发送不管顺序，也不管是否丢包，因此不会出现队头阻塞的问题，同时又使用了QUIC协议保证了类似于TCP的可靠传输。当某个stream丢包了，其他的stream不会因此阻塞。
      - 更快的建立连接：在1.1与2.0中TCP与TLS握手是分开单独进行的，而3.0的QUIC协议握手内部包含了TLS，QUIC目的连接目的是确认双方的连接ID
      - 连接迁移：TCP通过源IP、源端口、目的IP、目的端口确定一条TCP连接，当移动设备的网络从4g切换到wifi时，意味着IP地址改变了，就需要重新建立连接，而QUIC通过连接ID来确认双方，即使IP地址变化了，也可以无缝复原连接，不要再重新进行TCP握手、TLS握手

##### 2.2 HTTPS

1. http与https的区别

- - http的信息是明文传输的，存在安全风险，https在http层与tcp层之间加入了ssl/tls安全协议，是加密传输的。
  - https的ssl/tls需要进行握手
  - https的端口是443，而http的端口是80

1. https安全在哪

- - （**加密**）混合加密防止内容被窃听，（**校验**）摘要算法保证数据的完整性，（**身份证书**）数字证书进行身份验证
  - 混合加密 对称加密与非对称加密结合**，在通信建立前采用非对称加密（以安全地建立对称密钥即会话密钥），交换会话密钥**，在**通信过程中采用对称加密加密明文数据**。**对称加密只使用一个密钥速度更快，但是如果密钥泄露就可以被别人解析出来，非对称加密使用公钥和私钥，安全但速度慢。公钥可以公开给所有人，私钥不能对外泄露。**私钥与公钥可以双向加解密。公钥加密，可以使用私钥解密，私钥加密，可以使用公钥解密。**私钥由服务端保存**，**服务端向客户端发送对应的公钥**，客户端收到消息，能使用公钥解密，说明该消息是服务器发送的
  - 摘要算法（保证完整性）+数字签名（保证可靠性，确认对方是持有私密的一方）发送方将内容计算出来一个指纹，连同内容一起传递给对方，对方收到后对内容也计算一个指纹，与发送来的指纹进行比较，如果相同就说明数据内有被篡改，**摘要算法（为一个哈希函数）计算出内容的哈希值**，**摘要再使用公钥加密就得到数字签名（防止哈希值与内容被修改）**
  - 数字证书（**验证身份，防止服务器公钥钥被伪造**）**摘要算法可以保证内容完整性，数字签名保证消息是由持有私钥的一方发送的，即保证可靠性，但是不能保证内容与哈希值不会被中间人替换**，因此服务器将自己的公钥注册到CA中，CA使用自己的私钥将服务器的公钥数字签名并颁发数字证书，客户端拿到服务端的数字证书后使用CA的公钥进行解密，确认数字证书的真实性，再从数字证书中得到服务器的公钥，对数据加密发送。
  - TSL四次握手：先建立TCP连接（TCP的三次握手）

- - - 第一次握手：客户端发送Client Hello给服务端，其中包括TLS版本号、支持的加密算法、客户端生成的随机数（用于生成对称密钥）
    - 第二次握手：服务端发送Server Hello给客户端，其中包括服务端的TLS版本号、支持的加密算法、服务端生成的随机数。服务端还会发送自己的数字证书给客户端。
    - 校验证书：客户端收到服务端发送的数字证书，会使用CA机构的公钥来解密数字证书，得到服务端的公钥
    - 第三次握手：客户端在生成一个随机数，使用服务端的公钥进行加密，通过Client Key Exchange消息发送给服务端，服务端收到后使用服务端私钥解密得到第三个随机数，此时双方都有三个随机数，根据随机数生成对称密钥，客户端发送消息告诉服务端开始使用对称密钥，并且对之前的消息进行摘要使用对称密钥加密，发送给服务端，服务端校验对称密钥是否可用。
    - 第四次握手：服务端也会告诉客户端使用对称密钥，也对之前消息进行摘要使用对称密钥加密，发送给客户端校验对称密钥，收到ACK后四次握手完成，接下来使用对称密钥进行会话。

- - 客户端如何校验数字证书？CA对服务端的信息进行摘要算法计算出hash值，再用CA的私钥对hash值进行加密生成数字证书，当客户端得到数字证书，也会使用摘要算法计算出证书的hash值h1，再使用CA的公钥解密数字证书，得到h2，比较h1和h2是否相同，相同则证书可信。
  - 抓包工具为什么能得到https数据？因为抓包工具会把自己的证书加到系统的受信任根证书列表中。这样浏览器就会信任该证书。

##### 2.3 DNS

1. DNS如何解析？属于哪一层协议属于应用层协议，客户端访问DNS服务器前先查看浏览器和操作系统中是否有缓存域名所对应的IP地址，若没有再去查询本地DNS服务器查询，本地DNS服务器若有缓存则直接返回（本地DNS服务器采用递归查询），本地若没有则本地DNS服务器会去问根域名服务器（采用迭代查询，防止根域名服务器压力过大），找到顶级域名服务器，再到权威域名服务器，找到域名的IP地址再但返回给浏览器
2. DNS域名解析使用了什么协议？DNS域名解析的请求与响应都是基于UDP协议传输的，基于TCP的话需要三次握手与四次挥手，而且如果时对跟域名服务器进行迭代查询的话，会影响浏览器响应的时间，因此使用UDP提高响应实时性，减少建立与断开连接的开销，域名解析为短小而频繁的请求。但是UDP没法保证数据传输的可靠性，因此当UDP会被截断或超时时，可以使用TCP进行重试。
3. 域名如何知道端口？http默认使用80端口，https默认使用443端口，或者指定端口则使用指定的端口

##### 2.4 ARP

ARP只工作在局域网中，将目标IP地址通过广播的方式获取以太网中设备的MAC地址。

- 发送方的MAC地址：即为本机网卡的MAC地址
- 接收方MAC地址：在发送消息时，计算机根据本机**路由表**来根据数据包的目标IP地址决定发送时本机所使用的网卡的IP地址与下一跳的设备的IP地址（gateway）。ARP再根据下一调的IP地址广播获取到其MAC地址

#### 3. TCP 

1. TCP包头格式：**源端口号**，**目的端口号**，**序号**，**确认序号**，**状态位**，窗口大小，拥塞控制

序号：在建立连接时生成的随机数作为初始值，**每发送一次数据就累加一次数据字节数大小**，确定包的顺序，**解决网络包乱序的问题**

确认序号：**指接收端下一次希望收到的数据的序列号**，发送端收到确认序号后默认表示该确认序号前的数据都已经被接收端接受到，**用来解决丢包的问题**

窗口大小表示自己的处理能力，

状态位控制连接状态：

- - SYN表示希望建立连接，**并且会初始化序列号**。
  - ACK为回复，**ack为1时确认序号字段变为有效**，TCP规定除了建立连接SYN包之外ACK为必须为1。
  - fin表示希望断开连接，通信双方的主机相互交换FIN位为1的TCP字段。
  - RST表示TCP连接出现异常，强制断开连接,如由于网络阻塞导致的确认序号不一致等。

1. TCP用来保证数据包能够**无损坏、按顺序**可靠的传递给对方，有流量控制、超时重传、拥塞控制等。而IP层不能保证网络包顺序与完整性。

TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- - 源地址、源端口、目的地址、目的端口
  - TCP连接的限制：**文件描述符**，每个TCP连接都是一个文件，会收到系统级、用户级、进程级的文件描述符数量限制。**内存限制**，每个TCP连接都占用一定的内存，内存满了会触发OOM

1. TCP和UDP区别

UDP的包头：**源端口号、目的端口号、包长度、校验和**。包长度用于告诉接收端UDP首部与数据的长度和。校验和用于保证数据的完整性。

区别：TCP需要建立连接、TCP连接只能一对一通信、TCP保证数据交付的可靠性、TCP有流量控制。

TCP适用于：FTP文件传输、HTTP/HTTPS

UDP适用于：包总量较小的通信如DNS。视频、音频通信。广播通信。

1. TCP三次握手

- - 第一次握手：SYN报文，客户端随机初始化序列号放在TCP首部的序号字段中，设置状态位SYN为1（表示序号字段有效），把该报文发送给服务端，表示向服务端发起连接。之后客户端处于SYN-SENT状态
  - 第二次握手：SYN+ACK报文，服务端收到客户端的SYN报文后，服务端也会初始化自己的序号，将此序号填入TCP首部的序号字段中，同时会把确实序号字段填入收到的客户端序号+1，表示希望下次收到的报文的序号，接着把状态位的SYN和ACK状态位设为1（表示序号字段和确认序号字段有效），最后把该报文发送给客户端，之后服务端处于SYN-RCVD状态。
  - 第三次握手：ACK报文，客户端收到服务端报文后，将收到的服务端序号+1填入确实序号字段，将ACK状态位设置为1，并把报文发送回服务端，**此次握手可以携带应用层数据，而前两次不可以**，之后客户端处于ESTABLISHED状态。
  - 服务端收到客户端的报文后也进入ESTABLISHED状态。即连接完成。
    ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724232445506-b109fb80-0c67-48be-af6d-50c98f2d95a1.png)

1. 为什么是三次握手不是2次或4次？

**连接时三次握手才可以完成初始化socket、序列号、窗口大小**

**三次握手能保证双方具有接受和发送的能力，**

- **防止历史连接的建立**

- - 三次握手：（前后两个不同的SYN）如果客户端发送SYN=90后宕机重启了重新发送新的SYN=100的连接请求，**如果服务端先收到旧的SYN=90**就会发送SYN+ACK =91确认序号给客户端，客户端收到确认序号91后发现不是希望的101后就会在第三次握手时发送RST报文表示连接异常断开连接，服务端就会释放本次连接，就会防止历史连接。**如果服务端连续收到两个连接请求SYN=90与SYN=100，**那么先收到SYN=90会发送SYN+ACK=91返回给客户端，再收到新的SYN=100时就会返回Challenge ACK=91即接着返回上一次收到的SYN的确认序号，于是客户端发现确认序号与自己希望的确认序号不一样那么就会返回RST报文断开连接。
  - 如果为两次握手：那么服务端在收到SYN后就会进入ESTABLISH状态，服务端就可以发送数据给客户端，从而建立了历史连接，而不会像三次握手一样等待客户端确认后再建立连接

- **双方可靠同步初始化序列号**

- - 即客户端与服务端双方都需要SYN发送给对方序列号后再收到ACK应答表示序列号已经被对方成功接收。**双方都需要一来一回可靠的将序列号同步给对方。**
  - 四次握手也可以可靠的同步序列号给对方，但是可以将ACK与SYN融合为异步，就变成三次握手
  - 而两次握手只能保证一方的序列号可靠同步。没法让双方都SYN和ACK一收一发。

- **减少不必要的资源开支**

- - （前后两个相同的SYN）如果SYN=90因为网络阻塞了，没有收到ACK而超时重发。如果是两次握手，因为服务端不知道客户端是否收到了自己的ACK报文，所以对于每次收到的SYN都会建立一个连接，就会造成冗余的无效连接，造成资源浪费。如果是三次握手那么收到相同的ACK会根据确认序号丢弃重复的包。

1. 如果三次握手时，客户端已经进入ESTABLISH状态而第三次握手ACK还没有达到服务端，即服务端还是SYN_RCVD状态，客户端就发送数据到服务端，服务端也可以正常接收数据包，因为数据报文中是有ACK标识的，即确认序号，因此服务端收到报文可以正常建立连接。
2. 为什么每次建立TCP连接初始化的序列号都不一样？

- **为了防止历史报文被相同四元组的下一个连接接受**

- - 当新建连接的序列号每次都是从0开始的话，假如seq=1的消息被阻塞后，客户端与服务端重新建立了新的连接，此时上一个连接的seq=1的消息正好抵达服务端，且正好在服务端接受的窗口内就会被服务端接收，造成数据错乱。

1. 既然IP层会对大于MTU的数据包分片，为什么TCP层还需要MSS？

- 如果没有TCP层的分片，那么当组装的IP报文大于MTU，就会将TCP报文（TCP头部+TCP数据）切片重新组装成IP报文，此时如果在传输过程中有IP分片丢失了，那么会将这个IP分片所在的IP报文的全部分片重传，因为IP层没有重传机制，**只有TCP层有重传机制**，所以重传时时按照**整个TCP报文进行重传的**。如果对TCP报文按照MSS进行分片，形成的IP报文也不会超过MTU，即不会进行IP层分片，**会以MSS为单位对TCP分片进行重传，大大提高了重传的效率。**

1. 第一次握手丢失了会怎样

- 第一次握手客户端发送SYN报文，进入SYN_SENT状态，如果一直收不到服务端的SYN-ACK 报文（第二次握手），就会触发**「超时重传」**机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。

1. 第二次握手丢失了会怎样

-  服务端收到客户端的第一次握手后，会回复SYN+ACK给客户端，即第二次握手，服务端变成SYN_RCVD状态。因为第二次握手包含了服务端对第一次握手的ACK确认报文，所有如果客户端迟迟没有收到第二次握手，客户端会认为是第一次握手的SYN报文丢了，**客户端触发超时重传，重传SYN报文**。同时第二次握手会包含服务端的SYN报文，因此**服务端也会触发超时重传，重发SYN+ACK报文**。

1. 第三次握手丢失了会怎样？

- 客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。服务端如果一直没收到客户端的ACK报文，会认为是第二次握手丢失了，**服务端触发超时重传，重发SYN+ACK报文。**第三次握手客户端因为发送的ACK报文，**而ACK报文是不会重传的，当ACK丢失了，会由对方重传对应的报文**

1. 什么时SYN攻击，如何避免？

- 攻击者短时间伪造不同IP地址的SYN报文，服务端每收到一个SYN报文，就进入SYN_RCVD状态，但服务端发出的SYN+ACK报文不会得到未知IP的ACK应答，**久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务**。
- 流程：在TCP三次握手时，linux内核会维护两个队列，分别是半连接队列（收到SYN的连接）和全连接队列（收到了ACK的对象），服务端收到SYN报文时会创建一个办连接对象放入半连接队列中，并进行第二次握手，当收到客户端发来的ACK报文后，就会从半连接队列中取出一个半连接对象，并创建一个新的全连接对象放入全连接队列中，调用socket的accpet()函数后就会从accept队列中取出连接对象。当半连接或者全连接队列满了之后，默认会丢弃报文。于是服务端就无法在于其他客户端建立连接了
- 避免方法：方式一：调大 netdev_max_backlog，当网卡接收数据包速度大于内核处理速度时，会有一个队列保存这些数据包，**可以适当调大网卡保存数据包队列的值**。方式二：**增大 TCP 半连接队列**。方式三：开启 net.ipv4.tcp_syncookies，即**不通过半连接队列来建立连接**，当半连接队列满了之后，收到新的SYN包不会丢弃，而是算出一个**cookie**并放到第二次握手的序列号中，当服务端收到客户端的ACK时会验证这个ACK包的合法性，如合法将该连接放入全连接队列中。方式四：**减少 SYN+ACK 重传次数**，使得超过重连接次数并断开连接的速度变快

1. TCP四次挥手断开连接的过程？

- 客户端准备关闭连接，向服务端发送FIN报文并进入FIN_WAIT_1状态，
- 服务端收到后向客户端发送ACK应答报文并进入CLOSED_WAIT状态，客户端收到ACK后进入FIN_WAIT_2状态
- 服务端处理完数据后，也向客户端发送FIN报文，并进入LAST_ACK状态
- 客户端收到FIN后，回复ACK应答报文，并进入TIME_WAIT状态，服务端收到ACK应答后就进入close状态，服务端完成连接的关闭
- 客户端等待2MSL后，进入close状态，客户端完成连接的关闭

**客户端与服务端都需要一个FIN和ACK，客户端与服务端都可以主动关闭连接，但更多的是客户端主动关闭，****主动关闭连接的才有TIME-WAIT状态**

- ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724261786406-38986874-1a7f-4ebe-a913-0fc31e991cf5.png)

1. 为什么需要挥手四次？

[4.22 TCP 四次挥手，可以变成三次吗？](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)

客户端向服务端**发送FIN时仅仅表示客户端不能再发送数据了**，但是还可以接收数据，服务端收到SYN后返回一个ACK应答，**之后服务端可能还需要进行数据处理或发送**，等服务端确定不会再发送数据之后，才会发送FIN给客户端表示同意关闭连接。**因此服务端的ACK与FIN需要分开发送，所以是四次挥手。****只要调用了close()函数内核触发FIN，超时重发次数到了之后就一定关闭连接
**![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724305474313-d9b114e4-cb68-4cee-aed6-ead1064e26f2.png)

1. 第一次挥手丢失了会怎样？

- 客户端（主动关闭的一方）调用close函数后，向服务端发送FIN报文，此时客户端进入FIN_WAIT_1状态，如果第一次回收丢失了，客户端迟迟没有收到对方的ACK，**就会触发超时重传，重传FIN报文，超过一定的重传次数则直接进入close状态断开连接。**

1. 第二次挥手丢失了会怎样？

- 服务端收到客户端的FIN报文后，会回复ACK报文，并进入close_wait状态，**由于ACK报文是不会重传的**，因此客户端会认为是第一次握手丢失了，于是**客户端就会触发超时重传，重传FIN报文，直到收到服务端第二次握手或者达到最大重传次数客户端断开连接。**

1. 第三次挥手丢失了会怎样？

- 第二次握手后，服务端处于close_wait状态，即等待应用进程调用close函数关闭连接，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。第三次握手内核发出FIN报文，进入LAST_ACK状态，等待客户端ACK确认连接关闭，**若迟迟没收到ACK，服务端就会重发FIN报文，超过重试次数后服务端就关闭连接，同时客户端超时间没有收到第三次挥手的FIN也会超过FIN_WAIT_2的时长限制关闭连接**。同时第二次握手后客户端进入FIN_WAIT_2状态，但是由**于close函数关闭的连接，客户端会同时关闭接收和发送数据**，所以FIN_WAIT2 状态不可以持续太久，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如果客户端是用**shutdown函数关闭连接，即指定了只关闭发方向**，因此FIN_WAIT2会一直等待。

1. 第四次挥手丢失了会怎样？

- 客户端收到服务端的FIN报文后，就会回复ACK报文并进入TIME_WAIT状态，并开启时长为2MSL的定时器，如果途中再次收到了第三次挥手的ACK，就会重置定时器，等待2MSL后客户端就会断开连接，**如果第四次握手丢失，服务端会超时重发FIN报文，超过重试次数服务端断开连接，客户端超过TIME_WAIT的等待时间也会断开连接**。

1. 为什么TIME_WAIT等待时间2MSL?

- **MSL**(maximum segment lifetime)**报文最大生存时间，**即报文在网络中生存的最长时间，超过这个时间报文就会被路由器丢弃，用于限制报文在网络中传输的最大时间，MSL应当大于TTL确保消息消失在网络中了。
- TTL(time to live)为IP数据段可以经过的最大路由数，到达最大路由数则数据会被丢弃。
- 关闭方在第四次挥手发送完ACK报文后，进入TIME_WAIT状态，并等待2MSL后关闭连接(即一次消息往返)，**通过等待2MSL确保最后一次的ACK（客户端第四次挥手的ACK）与FIN（即可能服务端没收到第四次挥手的报文又重发了FIN）都被正确处理或者丢弃了，保证等待结束后网络上不会有旧连接的包了****。且如果在TIME_WAIT等待时间中客户端收到了重传的FIN报文，会重置TIME_WAIT定时器。**

1. 为什么需要TIME_WAIT状态？

- 主动发起关闭连接的一方，才会有TIME_WAIT状态
- **防止历史连接中的数据被相同四元组后面建立的新连接错误的接收**

- - 因为序列号与初始化序列号不是一直递增的，有可能旧连接的延迟数据在四元组的新连接建立后到达，且该数据包的序列号正好在接收端的窗口内，导致数据产生错乱，因此为了防止历史连接中的数据被错误的接收，**在TIME_WAIT等待的2MSL时长中，足以让两个方向上的数据包都再网络中被丢弃，等待时长之后的数据包就一定是新建连接所产生的了**

- **保证被动关闭连接的一方能被正确的关闭**

- - 即TIME_WAIT等待足够的时间保证最后第四次挥手的ACK能让对方接收到，若ACK对方没有收到，服务端就会重传FIN报文，一来一回刚好为2MSL的时间
  - 假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。强制关闭连接。

1. TIME_WAIT过多有什么危害？

- 占用端口资源（TIME_WAIT的等待时间中，该连接的四元组配对仍然保持占用状态，该四元组不能被其他连接复用）
- 占用系统资源（文件描述符、内存资源）
- 客户端的TIME_WAIT数量过多：**占用端口**如果每个端口都对相同的目的IP+目的端口建立连接占满了资源，就无法再对相同的目的IP+目的端口建立更多的连接了，但是只要是四元组中有一个不同，仍然可以建立新的连接，因为只要客户端连接的服务器（目的IP+目的端口）不同，端口资源可以重复使用的。
- 服务端的TIME_WAIT数量过多：**占用系统资源，**服务端会用内存资源、文件描述符维护连接信息。

1. 如何优化TIME_WAIT?   核心思想是试图越过TIME_WAIT的时间

- 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项

- - 允许对**处于TIME_WAIT状态的客户端相同四元组的连接进行复用**。通过检查时间戳保证新的连接不会因为旧连接的数据包出错。（即每个TCP包头都携带该数据包的发送时间，当对接口复用的时候，对比收到的包的时间戳与开启新连接的时间，如果收到的数据包的时间戳小于旧连接的时间戳，就会判断该为旧连接的数据包，并拒绝该数据包）

- 设置 net.ipv4.tcp_max_tw_buckets大小。即设置允许处于TIME_WAIT状态的TCP连接的数量，一旦超过这个数量，系统就会自动清理较早的处于TIME_WAIT状态的连接，从而释放系统资源。
- 程序中使用 SO_LINGER，通过设置socket，当调用socket的close()后，就会立即发送一个RST标志给对端，即跳过TCP的四次挥手，直接关闭连接。
- **应当不要避免TIME_WAIT状态，而是不要让服务端承受TIME_WAIT，即服务端不主动断开连接，而是让客户端去断开连接，承受TIME_WAIT**

1. 服务器出现大量的TIME_WAIT状态的原因是什么？

**TIME_WAIT是主动提出断开连接方才会出现的状态**

- HTTP没有使用长连接

- - 在HTTP/1.0中长连接是默认关闭的，在请求header中加上`Connection:Keep-Alive`字段，从而开启长连接，只要有一方的header中有`Connection:Close`就无法使用长连接，在HTTP/1.1中长连接是默认开启的，**不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接**

- HTTP长连接超时

- - 当超过一定的时间在TCP连接中没有请求与应答，nginx就会触发回调函数来关闭该连接，服务器就会主动关闭连接，当TCP连接中长时间没有发送请求，可以排查是否是由网络问题导致客户端发送的数据一直没有被服务端收到

- HTTP长连接的请求数量达到上限

- - 服务端通常会设置一个参数定义**一条TCP连接上所能最大处理的请求数量。**当超过该限制，服务端就会主动关闭该连接。如nginx的keepalive_requests参数，如果达到该值，nginx就会主动关闭该长连接。因此在某些QPS比较高的场景可以调大该参数

1. 服务器出现大量CLOSE_WAIT状态的原因

- 被动关闭方才会出现CLOSE_WAIT，**如果被动关闭方没有调用socket的close()函数关闭连接**，那么就无法发出FIN报文，就无法从CLOSE_WAIT变成LAST_ACK状态，**因此当服务端出现大量的CLOSE_WAIT时说明服务端没有调用close()函数发送FIN报文关闭连接**
- 所以主要方向就是排查问什么服务端没有调用close()函数，通常TCP服务端会创建服务端socket，bind并listen监听，将服务端socket注册到epoll中，epoll_wait等待连接来临，再调用accept获取连接，并将socket注册到epoll中，epoll_wait等待事件发生，如果是关闭连接事件，那么调用close关闭连接，再这个过程中可能会出现异常那么服务端就无法调用close，发送FIN报文，就一直处于CLOSE_WAIT状态

1. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

客户端出现故障即会导致长时间不与服务端通信，服务端如果无法感知客户端宕机，那么会一直处于ESTABLISH状态，占用系统资源。

- 应用层实现心跳机制

- - 如web服务器nginx可以设置keepalive_timeout参数用来指定**长连接的超时时间**，http请求后设置一个定时器，当超过定时器时间没有新的请求出现，那么就会触发回调函数关闭连接

- TCP协议的保活机制

- - Linux系统系统参数进行配置（**客户端与服务端都有**），定义一个时间段，如果超过该时间没有任何请求，TCP保活机制开始每隔一段时间发送一个探测报文，如果连续几个探测报文没有得到ACK响应，那么就会认为当前的TCP连接已经死亡并断开，应用程序要使用TCP的保活机制需要通过socket接口设置SO_KEEPALIVE选项才能生效。

1. 如果已经建立了连接，但是服务端进程崩溃了怎么办？

- TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

1. 如果TCP第三次握手丢失了，客户端已经处于了ESTABLISH状态，但是一直不发送数据，会断开连接吗？

- TCP的保活机制，会在一段时间内没有通信后，开启保活机制每隔一段时间发送一个探测保温，如果连接几个探测报文都没有得到ACK响应，那么会认为当前的TCP连接已经死亡，会断开连接。

1. TCP四次挥手可以变成三次吗？

- **在一些情况下，TCP四次挥手可以变成三次挥手。**即第二次挥手的ACK与CLOSE_WAIT后的第三次挥手的ACK一起发送。如果服务端开启了**TCP延迟确认机制**且**没有数据要发送**（推迟ACK的发送，在延迟确认的等待时间内，因为服务端没有数据要发送，所以就会调用FIN关闭连接，就会将ACK合并到要发送的FIN中一起发送）**，那么ACK和FIN就会一起发送，即第二次挥手与第三次挥手合并，就会出现三次挥手**
- ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724600280084-e78e03bf-683b-4dda-bbd8-ea8698af6fae.png)
- 当服务端收到客户端的FIN报文后会立即回复ACK应答报文，但服务端可能还有数据要响应，因此并不能马上发送FIN报文（发送完FIN报文即表示不会再发送数据了），由服务端应用程序决定什么时候发送FIN报文。等数据发送完后才系统调用关闭连接，
  	而关闭连接的函数有两种

- - close：**同时关闭socket在用户层面的的发送方向与读取方向（即无法接收发送数据，但是内核的四次挥手依然会完成）**，即socket不再有发送和接收数据的能力。那么在TCP四次挥手的时候，第三次挥手前服务端发送了数据给客户端，但是客户端已经没有接受数据的能力，那么客户端内核会返回RST报文给服务端，就不会经历完整的TCP四次挥手。
    ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724602468678-96f4682d-2e7f-48ff-bf5d-23a6652ae8f7.png)
  - shutdown：可以指定只关闭发送方向而不关闭接收方向，即在四次挥手的过程中，客户端依然可以接收服务端发送的数据，所以会经历完整的TCP四次挥手。同时shutdown也可以只关闭接收方向，不关闭发送方向，此时内核不会发送FIN关闭连接，因为FIN报文意味着不会再发送数据，而shutdown指定不关闭发送方向意味着socket还有发送数据的能力，因此内核就不会发送FIN关闭连接。
  - ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724604094738-3c74d964-7279-4570-9dcf-340971a76ee9.png)

#### 3.1 socket

1. 服务端没有listen，可以建立TCP连接吗？

- 客户端对服务端发起 SYN 报文后，服务端回了 RST 报文。**服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。**

1. 服务端没有accept，可以建立TCP连接吗？

- 可以，就算不执行accept，三次握手也会正常执行，建立连接的过程中不需要accept参与，因为accept是从全连接队列中获取已经建立好连接的socket。内核会为处于Listen状态的socket分配两个队列，分别是半连接队列与全连接队列，服务端收到第一次握手后会讲socket加入到半连接队列中，队列中的socket都处于send_recv状态，服务端收到第三次握手后会将半连接队列的socket取出并放到全连接队列中，队列中的socket处于ESTABLISH状态，并等待被accpet取出。

- - 半连接队列是一个哈希表，需要按照IP地址与端口取出对应的还未完成连接的socket。
  - 全连接队列是一个链表，因为其中都是已经建立完连接的socket，并不用关心是哪个连接。

#### 4. IP

- 寻址的时候不可能按照IP一个个匹配，因此将IP地址分为两种意义，一个是网络号，标识IP地址属于哪个子网，一个是主机号，标识同一子网下的不同主机，并通过子网掩码，算出Ip地址的网络号与主机号。寻址时会先找到相同的网络号再去寻找其中对应的主机
- **以太网中判断网络包地址使用MAC地址，不同网络之间寻址使用IP地址**

1. IP包头：原地址ip，目标地址ip，协议号原地址ip即客户端输出的ip地址，目标地址ip即DNS服务器解析出来的Ip，协议号为十六进制06表示为TCP。
2. 当客户端有多个网卡，怎么决定原地址的IP？根据系统的路由表，查看路由表中与目标地址网络号所对应的网卡的IP地址。路由表中子网掩码都为0.0.0.0，且网络号0.0.0.0对应的是默认路由。
3. 为什么有了IP地址，还需要MAC地址？Ip地址是设备上线后根据子网分配得到的，Ip地址是网络层定位地址的，MAC是在局域网中定位设备，在数据链路层中使用的地址，如果只有没有mac地址，那么在设备还没ip地址时，无法通信。mac地址是硬件写死的，更安全的区分用户。
4. 路由器和交换机区别

- - 交换机工作在数据链路层，路由器工作在网络层。
  - 交换机根据MAC地址转发数据，路由器根据IP地址交换数据。交换机中维护MAC地址表，将收到包的mac地址转化为对应的端口号。
  - 路由器每个端口有MAC地址和IP地址，交换机的端口只有IP地址。路由器有MAC地址，可以成为交换机的收发方。

1. 交换机 工作在数据链路层 **根据MAC地址将数据发给相应的端口**

- - 功能：组建局域网，但是没法让局域网连入互联网
  - 接受到数据（**通过MAC地址，可以将数据从客户端到路由器，也可以从路由器到客户端**）：收到数据帧，读取帧头的MAC与交换机接口，根据维护的MAC地址表将**MAC地址转化为对应的端口**进行单播
  - 若交换机的MAC地址表中没有该MAC的记录么办？：若MAC地址表中没有该MAC的端口，则进广播，发送到所有端口，对应MAC地址的设备才能接受包并响应，其他设备忽略该包。
    ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132363304-9133243a-5839-4557-8346-35496ef1cbc1.png)

1. 路由器 工作在网络层 基于IP进行转发

- - 路由器中维护路由表：将接收方IP地址转换为对应的端口（接收方ip地址与子网掩码位运算再匹配）
  - 接收操作：从交换机收到数据包，检查收到的包中的MAC是不是自己的，不是则丢弃这个包
  - 转发操作：收到包后，去掉包的MAC头部（**因为只有交换机通过MAC头传输包，路由器收到的包中的MAC作用就是将包从交换机发送到路由器**），路由器根据IP进行转发，路由表将将IP地址转换为对应的端口，若没找到则走默认路由（网络号为0.0.0.0，子网掩码为0），根据路由表中目标地址对应的网关，若网关不为空则将包路由给下一个路由器，若为空则说明已经该包IP地址就是目标地址了，已经到达了路由器的终点，接下来通过ARP协议获得该IP的MAC地址，原地址MAC字段为路由器输出端口的MAC地址，将MAC包发送到下个交换机，交换机会再将包发给下个路由器，直到到达目的地。**网络包的MAC地址在传输中会不停的变换**，因为需要MAC地址在两个设备间进行传输
    ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132370347-9d3a3423-1160-4e2c-be55-f6f8a9b64bc6.png)

#### 5. 场景题

1. 如果浏览器没有显示页面有哪些原因？（**网络，DNS，TCP三次握手，响应状态码**）

- - 先判断是客户端问题还是服务端的问题，浏览器如果可以访问其他网站，说明客户端网络连接是否正常，如果不可以，可能时客户端问题，检查网络配置。
  - 如果浏览器没问题，就抓包（浏览器F12、wireshark），先查看DNS是否解析出了IP地址，如果没有解析出来，则说明域名写错了，如果解析出了IP地址，抓包确认有没有和服务端建立三次握手。如果没有成功建立三次握手，则需要在服务端确认server进程是否启动了，以及确认是否监听了端口。如果能建立三次握手，且发出了HTTP请求，但是没有显示页面，可以查看服务端响应的状态码（404则表示请求的资源不存在，500标识服务端出现问题，检查服务端日志，如果为200，则表示成功，需要查看是否是前端代码有问题导致浏览器没有渲染出页面）。
  - 如果客户端网络正常，但是访问速度很慢，很久才显示，则可以ping去检查网络延迟是否正常，如果时间很长，可以排查服务器流量是不是很大，导致丢包，如果流量正常，可以排查接口，是不是慢sql导致。

![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724132378587-4937e4d4-e964-4992-94a3-e8f8f27f98ad.png)

#### 6. linux指令

- 查看TCP的连接状态

- - TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。 t表示查看TCP的连接，a表示显示所有连接中的socket， **n标识直接显示IP地址，而不用域名
    **![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724231502727-32a453f9-938a-4420-aa0e-0fd9cea40024.png)

- 路由表

- - 使用 `route -n` 命令查看当前系统的路由表。gateway即表示转发的网关（路由器）地址，若gateway为0.0.0.0则是与接口直接连接的设备默认网关，不用IP转发了，通过ARP找到对方的MAC地址并直接通过接口发送到下一设备。
  - ![img](https://cdn.nlark.com/yuque/0/2024/png/46064027/1724163771101-cf60ea65-a11b-45f4-9c21-5321a38138e5.png)

- 查看ARP缓存

- - 使用 `arp -a`查看所有缓存的的IP与其MAC地址