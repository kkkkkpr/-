[toc]

#### 1. 基础

1. 为什么要有TCP/IP：同一台设备上进程间的通信有管道、消息队列、共享内存、信号等方式，**而 **。而这个TCP/IP协议是分层的，每层有各自的职责并与其上下层进行通信
2. OSI七层协议：（应表会传网数物）
   - **应用层功能包括验证资源可用性和支持传输任何数据格式 **，表示层将数据编码和解码与压缩与加密解密 ，会话层控制设备的连接与断点续传，**传输层将数据分解为多个数据段与加上TCP头和重组数据并进行流量控制与传输的完整性** ，**网络层进行两个不同网络之间的寻址与数据路由**并且将传输层的数据段进一步分解为数据包，数据链路层提供同一网络上两台设备之间的数据传输，物理层定义物理设备的规格如电缆工作电压、无线设备的频率，将数据转换为位流。
   - 应用层协议有（HTTP、HTTPS、DNS），传输层协议有（TCP、UDP），网络层协议有（IP、ARP、ICMP）。OSI只是理论模型，实际上因特网的网络模型使用了TCP/IP网络，对OSI进行了简化，把应用层、表示层、会话层统一为了应用层，数据链路层和物理层统一为了网络接口层。
3. TCP/IP有哪几层：应用层、传输层、网络层、网络接口层。
   - 应用层：（**HTTP报文**）为应用程序提供了访问其他层的能力，定义**了应用程序交换数据的协议**（HTTP、HTTPS、DNS）
     - **即忽略如何传输给对方，只关心客户端和服务端如何传输和处理通信资源（如http请求/响应报文）**
   - 传输层：（**添加TCP头**）为应用程序提供数据传输服务，**为了方便传输将数据分为多个小数据控制并添加TCP头部**，进行流量控制，保证数据传输的完整性。（TCP提供一对一的可靠传输，UDP提供一对一或一对多的不可靠的传输，TCP比UDP多了流量控制、超时重传、拥塞控制等），
     - **提供处于网络连接中的两个计算机之间的数据传输**
   - 网络层：（**添加IP头**）负责IP寻址和路由功能，（IP协议负责寻址和路由，ARP协议地址解析获得MAC地址，ICMP提供诊断并报告错误）、分片（**MTU规定IP包的大最大为1500字节**），
     - **处理在网络中流动的数据包如何找到对方计算机的路径**
   - 网络接口层：（**添加MAC头，将TCP/IP包封装成帧**）将TCP/IP数据包放到网络介质上并从网络介质上接受TCP/IP数据包，，如以太网、WIFI等。使用MAC地址标识网络上的设备（在以太网中用MAC地址，使用ARP获取对方地址）
     - **处理连接网络的硬件部分（包括网卡、操作系统、路由器等）**，**使得TCP/IP包可以连接不同的网络类型**
4. 为什么要分层？ 
   首先可以进行解耦，每层不用关心上下层的实现，只使用提供的接口服务，将大问题转化为若干小问题，同时若发生网络问题可以快速定位到在哪一层，而且分层后若某层发生改动，其他层不受到影响。如ipv4升级到ipv6，http1.0升级到http2.0
5. 键入网址后，期间发生了什么？
   1. 解析URL，确定服务器名（域名），资源路径，端口信息，进而生成http请求报文（包括请求头，消息行，消息体）。
   2. 域名解析，查询服务器对应的IP地址。DNS服务器保存了web域名与IP的对应关系（域名服务器的层级关系类似一个树状结构，根域的DNS服务器信息保存在所有DNS服务器中，因此任何一个DNS服务器可以通过根域服务器一路向下找到目标DNS服务器），
      流程：浏览器先看本地有没有该域名缓存，若有则直接返回，再问操作系统的缓存，再问hosts文件，都没有再去本地DNS服务器，本地DNS服务器若有缓存则直接返回IP地址，本地若没有则去问根域名服务器，找到顶级域名服务器，再到权威域名服务器，找到域名的IP地址再但返回给浏览器
   3. HTTP包通过TCP传输，在发送HTTP请求之前要进行TCP三次握手，第一次握手客户端TCP头部状态位SYN，之后处于SYN-SEND状态，服务端收到后返回SYN并且ACK客户端的SYN，客户端收到服务端的SYN+ACK之后，发送对SYN的ACK，之后处于establised状态（因为一发一收成功），服务端收到客户端的ACK之后也处于establed状态，因为也一发一收成功了。
   4. 到网络层，在TCP连接，收发，断开时都要为TCP包加上IP头，封装成网络包发送给对象。
   5. 再由ARP获得路由器的MAC地址，添加MAC头（源MAC地址和目标MAC地址），首次MAC地址的获取需要ARP在以太网中以广播的形式得到ip地址对应的机器的MAC地址
   6. （经过交换机和路由器）找到目标服务器，进行三次握手
   7. 当三次握手完成，将请求发送到服务器，服务器响应请求，浏览器收到响应进行解析渲染，呈现出来
6. Linux如何收发网络包
   应用程序通过系统调用，将数据写到socket中，socket层下面就是传输层，网络层，网络接口层，DMA。
   - 发送：应用程序调用socket发送数据包的接口，为系统调用，将数据从用户空间拷贝到socket发送缓冲区，网络协议栈从socket缓冲区取出数据，并按照TCP/IP协议从上到下处理，使用TCP传输协议发送数据，会拷贝一个新的socket缓冲副本，因为TCP是支持丢失重传的，在收到对方的ACK之前，不会删除这个socket数据，收到ACK之后才会删除（副本被送往网络层，发送完被删除，原始的sk_buff还保存在传输层，等收到ACK时，才会释放原始sk_buff）

#### 2. 应用层

##### 2.1 HTTP	

1. http是什么？
   超文本传输协议，定义点到点之间传输数据（文字、图片、音频、视频等超文本）的规范，用于web客户端与web服务器之间通信。

2. 报文格式：

   - 请求报文：报文首部，报文主体。报文首部包含（请求行，首部字段），请求行为包含（方法，URI，HTTP版本）
   - 响应报文：报文首部包含（HTTP版本、状态码、首部字段）
     <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240502111552031.png" alt="image-20240502111552031" style="zoom:80%;" />

   - 通用首部：Cache-Control：请求与响应控制缓存的行为。Connection控制不再转发给代理的首部字段（即为逐条首部），管理持久连接（为close时表示想断开连接，为keep-alive时表示维持连接）。Date表示报文的创建时间。Trailer标识报文主体后出现的首部字段。Transfer-Encoding报文主体采用的编码方式。Via用于追踪请求和响应报文的传输路径（类似于traceout，每经过代理时在Via字段中添加该服务器的信息再转发）
   - 请求首部：Accept通知服务端客户端可以处理的数据类型（type/subtype，还可以指定优先级，先返回优先级高的资源）。Accept-Charset通知服务端客户段支持的字符集。Accept-Encoding为客户端支持的编码方式。Authorization告知服务端用户端的证书认证。Host指定虚拟主机（因为在同一个IP中可能有部署多个域名）。If-Match用于让服务端验证Etag。If-modified-since如果在指定时间之后更新过，服务端可以接受该资源。Max-forward指定可以经过服务器跳转的最大个数。Range指定获取资源的字节范围。User-Agent用于传达浏览器的种类。referer可以让服务端知道请求的原始资源的URI。

3. URI和URL：URI（uniform resource identifier）统一资源标识符，用于标识某一互联网中的资源，URL统一资源定位符，标识资源所在的具体网络地址，标识网络资源除了通过地址以外还有其他的方式（如唯一资源名称）因此URL是URI的一个子集

4. URL和HTTP：URL是定位网络上资源的地址，HTTP协议是网络上传输的协议，URL中会指定HTTP协议。
   <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240429213948408.png" alt="image-20240429213948408" style="zoom:50%;" />

5. 状态码
   1xx为提示信息，为处理的中间状态，2xx表示服务器成功处理了请求，3xx表示重定向，4xx表示客户端请求报文有错，5xx表示服务器处理时内部发生错误

6. http header常见字段
   host表示请求服务器的域名，content length服务器返回数据的长度，connection字段常用于客户端要求服务器进行长连接以进行请求复用，content-type表示服务器返回客户端的数据格式编码方式，accept表示客户端接受什么格式的数据，content-encoding表明响应的数据压缩的方法

7. get与post区别
   get是指从服务器获取资源，请求参数一般写在url中（只支持ascii码），post是根据请求头对请求负荷body做出指定处理，参数一般写在body中，get因为是请求资源所以是安全且幂等的，post会对服务器资源进行修改，所以是不安全也不幂等的

8. http缓存技术
   某些具有重复性的http请求，每次请求得到的数据都一样，可以将这个请求与响应的数据都缓存在本地，下次请求就读取本地的响应，不再通过服务器进行响应，分为强制缓存和协商缓存
   - 强制缓存：**即只要浏览器判断缓存没有过期，就直接使用浏览器本地的缓存，即浏览器决定是否使用缓存**，通过http header的字段cache-Control实现相对时间，浏览器第一次发起请求时**服务器会在响应的头部加上cache-control设置过期时间**，浏览器下次请求该资源的时候会先比较cache-control过期时间大小，计算该资源是否过期，没有过期则直接使用缓存，否则请求服务器，服务器会响应资源并且更新cache-control
   - 协商缓存（**协商缓存需要配合强制缓存在使用，强制缓存未命中才发起协商缓存**）：如服务器响应码为304就会使用本地缓存，**即与服务器协商是否使用缓存**，
     - Last-modified基于修改时间：第一次请求时**服务器会响应Last-modified字段表示这个资源的最后修改时间，浏览器请求时会将本地的last-modified字段一起发给服务器，服务器比较last-modified的大小**，如果服务器比请求的要大，表示资源有修改过，会返回最新的资源，否则说明资源没有修改，返回304表示浏览器访问本地的缓存。
     - Etag基于唯一标识：服务器比较Etag是否变化，若变化则返回新资源，状态码为200。否则没有修改则返回304浏览器访问本地资源。
       Last-modified与Etag同时出现则Etag优先级高，因为可能文件修改时间没变的情况下文件内容也可以变化，资源可能在秒内发生修改，而Last-modified并没有改变。
       <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240409203918521.png" alt="image-20240409203918521" style="zoom:50%;" />

9. HTTP/1.1、HTTP/2、HTTP/3

   - HTTP/1.1对HTTP/1.0的提高

     - 1.1使用长连接改善了短连接的性能开销，长连接不用每次请求都要进行三次握手。（**即1.0中收到一个响应才能发送下一请求**）
     - 支持pipline管道，**第一个请求发完不用等待响应就可以发送第二个请求，但是响应按照请求顺序返回**。
     - 1.1缺点：服务器是按请求的顺序进行响应，如果某个响应阻塞了可能会导致队头阻塞。头部不加压缩就发送，比较浪费。请求没有优先级控制。

   - HTTP/2.0做了什么优化？ （**头部压缩、二进制传输、Stream并发传输、服务器主动推送**）

     - HTTP/2.0也是基于HTTPS的，会加密传输。
     - 会**对请求头Header压缩**，在客户端与服务端维护一个请求头信息表，保存请求头信息，之后就不用发送相同的字段了，只发索引号，提高速度
     - 1.1中是纯文本的ASSIC码报文，机器还要将二进制转化为明文报文，而2.0中**报文是二进制格式**，对计算机友好，节省空间并且加快传输的效率，将首部和负载分为两类帧HEADERS和DATA帧，
     - 1.1中同一个连接，响应是按照请求顺序返回的，会有队头阻塞的问题，2.0中采用stream流的设计，**多个stream复用一条TCP连接**，stream中可以包含一个或者多个Message，**一个Message可以看做一个请求或者响应**，Message中又包含多个Frame帧，**即一个stream中可以可以有多个请求或响应**（同一个HTTP请求与响应在同一个Stream中）。不同的Stream帧是可以乱序发送的（**即可以并发不同的Stream**），每一个Frame头部带有streamID，接收端收到帧后通过StreamID将帧组装成THHP消息，**而同一Stream中帧是有序的**，即2.0中实现100个请求并发时，只需要在一个TCP连接中并发100个stream就行了（类似于多路复用），而1.1中并发需要建立100个TCP连接（类似于多线程处理IO）
     - 1.1中服务端响应需要客户端请求才行，而2.0中服务端可以主动向客户端推送资源，比如客户端请求了HTML文件，还需要请求HTML所依赖的JS、CSS文件，而2.0中服务端可以主动推送HTML文件所依赖的资源，减少请求次数。（**可以在Nginx中配置推送的资源**），服务端会在响应的时候，通过PUSH-PROMISE帧告知客户端，接下来推送的资源所在的streamID（服务端使用偶数stream，客户端使用奇数stream）

   - HTTP/3的优化

     - 1.1使用管道技术解决了请求的队头阻塞，但是没有解决响应的队投阻塞。2.0使用多个stream复用一个TCP连接，但是一旦丢包就会阻塞所有的HTTP请求，会发生TCP层的队头阻塞。
     - 2.0中使用TCP协议来传输数据，TCP是字节流协议，**TCP层必须保证接收到的字节数据是完整且连续的，内核才会将缓冲区中的数据拷贝到用户空间中**，当中间某个数据还没有到达时，即使后面的数据到达了也无法返回给用户空间，只能放在内核空间中，只有等到这个数据到达内核才会把数据返回给程序，**即会发生TCP层面的队头阻塞。当发生丢包，在一个TCP连接中的所有HTTP请求都必须等待这个丢了的包重传回来。**
     - 3.0优化：**无队头阻塞、更快的连接建立、连接迁移 ** QUIC是基于UDP的伪TCP+TLS+2.0多路复用。
       - 无队头阻塞：3.0将TCP协议改成了UDP协议，UDP发送不管顺序，也不管是否丢包，因此不会出现队头阻塞的问题，同时又使用了QUIC协议保证了类似于TCP的可靠传输。当某个stream丢包了，其他的stream不会因此阻塞。
       - 更快的建立连接：在1.1与2.0中TCP与TLS握手是分开单独进行的，而3.0的QUIC协议握手内部包含了TLS，QUIC目的连接目的是确认双方的连接ID
       - 连接迁移：TCP通过源IP、源端口、目的IP、目的端口确定一条TCP连接，当移动设备的网络从4g切换到wifi时，意味着IP地址改变了，就需要重新建立连接，而QUIC通过连接ID来确认双方，即使IP地址变化了，也可以无缝复原连接，不要再重新进行TCP握手、TLS握手

     

##### 2.2 HTTPS

1. http与https的区别
   - http的信息是明文传输的，存在安全风险，https在http层与tcp层之间加入了ssl/tls安全协议，是加密传输的。
   - https的ssl/tls需要进行握手
   - https的端口是443，而http的端口是80

2. https安全在哪
   - （**加密**）混合加密防止内容被窃听，（**校验**）摘要算法保证数据的完整性，（**身份证书**）数字证书进行身份验证
   - 混合加密      
     对称加密与非对称加密结合**，在通信建立前采用非对称加密（以安全地建立对称密钥即会话密钥），交换会话密钥**，在**通信过程中采用对称加密加密明文数据**。**对称加密只使用一个密钥速度更快，但是如果密钥泄露就可以被别人解析出来，非对称加密使用公钥和私钥，安全但速度慢。公钥可以公开给所有人，私钥不能对外泄露。**
     私钥与公钥可以双向加解密。公钥加密，可以使用私钥解密，私钥加密，可以使用公钥解密。
     **私钥由服务端保存**，**服务端向客户端发送对应的公钥**，客户端收到消息，能使用公钥解密，说明该消息是服务器发送的
   - 摘要算法（保证完整性）+数字签名（保证可靠性，确认对方是持有私密的一方）
     发送方将内容计算出来一个指纹，连同内容一起传递给对方，对方收到后对内容也计算一个指纹，与发送来的指纹进行比较，如果相同就说明数据内有被篡改，**摘要算法（为一个哈希函数）计算出内容的哈希值**，**摘要再使用公钥加密就得到数字签名（防止哈希值与内容被修改）**
   - 数字证书（**验证身份，防止服务器公钥钥被伪造**）
     **摘要算法可以保证内容完整性，数字签名保证消息是由持有私钥的一方发送的，即保证可靠性，但是不能保证内容与哈希值不会被中间人替换**，因此服务器将自己的公钥注册到CA中，CA使用自己的私钥将服务器的公钥数字签名并颁发数字证书，客户端拿到服务端的数字证书后使用CA的公钥进行解密，确认数字证书的真实性，再从数字证书中得到服务器的公钥，对数据加密发送。
   - TSL四次握手：先建立TCP连接（TCP的三次握手）
     - 第一次握手：客户端发送Client Hello给服务端，其中包括TLS版本号、支持的加密算法、客户端生成的随机数（用于生成对称密钥）
     - 第二次握手：服务端发送Server Hello给客户端，其中包括服务端的TLS版本号、支持的加密算法、服务端生成的随机数。服务端还会发送自己的数字证书给客户端。
     - 校验证书：客户端收到服务端发送的数字证书，会使用CA机构的公钥来解密数字证书，得到服务端的公钥
     - 第三次握手：客户端在生成一个随机数，使用服务端的公钥进行加密，通过Client Key Exchange消息发送给服务端，服务端收到后使用服务端私钥解密得到第三个随机数，此时双方都有三个随机数，根据随机数生成对称密钥，客户端发送消息告诉服务端开始使用对称密钥，并且对之前的消息进行摘要使用对称密钥加密，发送给服务端，服务端校验对称密钥是否可用。
     - 第四次握手：服务端也会告诉客户端使用对称密钥，也对之前消息进行摘要使用对称密钥加密，发送给客户端校验对称密钥，收到ACK后四次握手完成，接下来使用对称密钥进行会话。
   - 客户端如何校验数字证书？
     CA对服务端的信息进行摘要算法计算出hash值，再用CA的私钥对hash值进行加密生成数字证书，当客户端得到数字证书，也会使用摘要算法计算出证书的hash值h1，再使用CA的公钥解密数字证书，得到h2，比较h1和h2是否相同，相同则证书可信。
   - 抓包工具为什么能得到https数据？因为抓包工具会把自己的证书加到系统的受信任根证书列表中。这样浏览器就会信任该证书。

   

##### 2.3 DNS

1. DNS如何解析？属于哪一层协议
   属于应用层协议，客户端访问DNS服务器前先查看浏览器和操作系统中是否有缓存域名所对应的IP地址，若没有再去查询本地DNS服务器查询，本地DNS服务器若有缓存则直接返回（本地DNS服务器采用递归查询），本地若没有则本地DNS服务器会去问根域名服务器（采用迭代查询，防止根域名服务器压力过大），找到顶级域名服务器，再到权威域名服务器，找到域名的IP地址再但返回给浏览器
2. DNS域名解析使用了什么协议？
   DNS域名解析的请求与响应都是基于UDP协议传输的，基于TCP的话需要三次握手与四次挥手，而且如果时对跟域名服务器进行迭代查询的话，会影响浏览器响应的时间，因此使用UDP提高响应实时性，减少建立与断开连接的开销，域名解析为短小而频繁的请求。但是UDP没法保证数据传输的可靠性，因此当UDP会被截断或超时时，可以使用TCP进行重试。
3. 域名如何知道端口？
   http默认使用80端口，https默认使用443端口，或者指定端口则使用指定的端口

#### 3. TCP 

1. TCP包头格式：**源端口号**，**目的端口号**，**序号**，**确认序号**，**状态位**，窗口大小，拥塞控制

   序号：在建立连接时生成的随机数作为初始值，**每发送一次数据就累加一次数据字节数大小**，确定包的顺序，**解决网络包乱序的问题**

   确认序号：**指接收端下一次希望收到的数据的序列号**，发送端收到确认序号后默认表示该确认序号前的数据都已经被接收端接受到，**用来解决丢包的问题**

   窗口大小表示自己的处理能力，

   状态位控制连接状态：

   - SYN表示希望建立连接，**并且会初始化序列号**。
   - ACK为回复，**ack为1时确认序号字段变为有效**，TCP规定除了建立连接SYN包之外ACK为必须为1。
   - fin表示希望断开连接，通信双方的主机相互交换FIN位为1的TCP字段。
   - RST表示TCP连接出现异常，强制断开连接。

2. TCP用来保证数据包能够**无损坏、按顺序**可靠的传递给对方，有流量控制、超时重传、拥塞控制等。而IP层不能保证网络包顺序与完整性。

   TCP 四元组可以唯一的确定一个连接，四元组包括如下：

   - 源地址、源端口、目的地址、目的端口
   - TCP连接的限制：**文件描述符**，每个TCP连接都是一个文件，会收到系统级、用户级、进程级的文件描述符数量限制。**内存限制**，每个TCP连接都占用一定的内存，内存满了会触发OOM

3. TCP和UDP区别

   UDP的包头：**源端口号、目的端口号、包长度、校验和**。包长度用于告诉接收端UDP首部与数据的长度和。校验和用于保证数据的完整性。

   区别：TCP需要建立连接、TCP连接只能一对一通信、TCP保证数据交付的可靠性、TCP有流量控制。

   TCP适用于：FTP文件传输、HTTP/HTTPS

   UDP适用于：包总量较小的通信如DNS。视频、音频通信。广播通信。

4. TCP三次握手

   - 第一次握手：SYN报文，客户端随机初始化序列号放在TCP首部的序号字段中，设置状态位SYN为1（表示序号字段有效），把该报文发送给服务端，表示向服务端发起连接。之后客户端处于SYN-SENT状态
   - 第二次握手：SYN+ACK报文，服务端收到客户端的SYN报文后，服务端也会初始化自己的序号，将此序号填入TCP首部的序号字段中，同时会把确实序号字段填入收到的客户端序号+1，表示希望下次收到的报文的序号，接着把状态位的SYN和ACK状态位设为1（表示序号字段和确认序号字段有效），最后把该报文发送给客户端，之后服务端处于SYN-RCVD状态。
   - 第三次握手：ACK报文，客户端收到服务端报文后，将收到的服务端序号+1填入确实序号字段，将ACK状态位设置为1，并把报文发送回服务端，**此次握手可以携带应用层数据，而前两次不可以**，之后客户端处于ESTABLISHED状态。
   - 服务端收到客户端的报文后也进入ESTABLISHED状态。即连接完成。

5. 为什么是三次握手不是2次或4次？

   ==**三次握手能保证双方具有接受和发送的能力，防止历史连接的建立，能够帮助双方可靠同步初始化序列号（即发送序列号给对方也要得到对方的应答确实对方收到了）**==

   

#### 4. IP

1. IP包头：原地址ip，目标地址ip，协议号
   原地址ip即客户端输出的ip地址，目标地址ip即DNS服务器解析出来的Ip，协议号为十六进制06表示为TCP。
2. 当客户端有多个网卡，怎么决定原地址的IP？
   根据系统的路由表，查看路由表中与目标地址网络号所对应的网卡的IP地址。路由表中子网掩码都为0.0.0.0，且网络号0.0.0.0对应的是默认路由。
3. 为什么有了IP地址，还需要MAC地址？
   Ip地址是设备上线后根据子网分配得到的，Ip地址是网络层定位地址的，MAC是在局域网中定位设备，在数据链路层中使用的地址，如果只有没有mac地址，那么在设备还没ip地址时，无法通信。mac地址是硬件写死的，更安全的区分用户。
4. 路由器和交换机区别
   - 交换机工作在数据链路层，路由器工作在网络层。
   - 交换机根据MAC地址转发数据，路由器根据IP地址交换数据。交换机中维护MAC地址表，将收到包的mac地址转化为对应的端口号。
   - 路由器每个端口有MAC地址和IP地址，交换机的端口只有IP地址。路由器有MAC地址，可以成为交换机的收发方。
5. 交换机 工作在数据链路层 **根据MAC地址将数据发给响应的端口**
   - 功能：组建局域网，但是没法让局域网连入互联网
   - 接受到数据（**通过MAC地址，可以将数据从客户端到路由器，也可以从路由器到客户端**）：收到数据帧，读取帧头的MAC与交换机接口，根据维护的MAC地址表将**MAC地址转化为对应的端口**进行单播
   - 若交换机的MAC地址表中没有该MAC的记录么办？：若MAC地址表中没有该MAC的端口，则进广播，发送到所有端口，对应MAC地址的设备才能接受包并响应，其他设备忽略该包。
     <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240403170244770.png" alt="image-20240403170244770" style="zoom:50%;" />
6. 路由器 工作在网络层 基于IP进行转发
   - 路由器中维护路由表：将接收方IP地址转换为对应的端口（接收方ip地址与子网掩码位运算再匹配）
   - 接收操作：检查收到的包中的MAC是不是自己的，不是则丢弃这个包
   - 转发操作：收到包后，去掉包的MAC头部（**因为只有交换机通过MAC头传输包，路由器收到的包中的MAC作用就是将包从交换机发送到路由器**），路由器根据IP进行转发，路由表将将IP地址转换为对应的端口，若没找到则走默认路由（网络号为0.0.0.0，子网掩码为0），根据路由表中目标地址对应的网关，若网关不为空则将包路由给下一个路由器，若为空则说明已经该包IP地址就是目标地址了，已经到达了路由器的终点，接下来通过ARP协议获得该IP的MAC地址，原地址MAC字段为路由器输出端口的MAC地址，将MAC包发送到下个交换机，交换机会再将包发给下个路由器，直到到达目的地。**网络包的MAC地址在传输中会不停的变换**，因为需要MAC地址在两个设备间进行传输
     <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240403181228152.png" alt="image-20240403181228152" style="zoom:50%;" />

#### 5. 场景题

1. 如果浏览器没有显示页面有哪些原因？（**网络，DNS，TCP三次握手，响应状态码**）

   - 先判断是客户端问题还是服务端的问题，浏览器如果可以访问其他网站，说明客户端网络连接是否正常，如果不可以，可能时客户端问题，检查网络配置。

   - 如果浏览器没问题，就抓包（浏览器F12、wireshark），先查看DNS是否解析出了IP地址，如果没有解析出来，则说明域名写错了，如果解析出了IP地址，抓包确认有没有和服务端建立三次握手。如果没有成功建立三次握手，则需要在服务端确认server进程是否启动了，以及确认是否监听了端口。如果能建立三次握手，且发出了HTTP请求，但是没有显示页面，可以查看服务端响应的状态码（404则表示请求的资源不存在，500标识服务端出现问题，检查服务端日志，如果为200，则表示成功，需要查看是否是前端代码有问题导致浏览器没有渲染出页面）。
   - 如果客户端网络正常，但是访问速度很慢，很久才显示，则可以ping去检查网络延迟是否正常，如果时间很长，可以排查服务器流量是不是很大，导致丢包，如果流量正常，可以排查接口，是不是慢sql导致。
     <img src="C:\Users\10122\AppData\Roaming\Typora\typora-user-images\image-20240403234410128.png" alt="image-20240403234410128" style="zoom:50%;" />























